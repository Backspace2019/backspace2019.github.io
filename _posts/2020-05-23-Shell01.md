---
layout:     post
title:      "[Shell]脚本编程学习札记"
subtitle:   在Linux环境下进行
date:       2020-05-23 00:00:00
author:     "Backspace"
header-img: "img/post-bg-apple-event-2015.jpg"
tags:
    - shell
---

## 解析器

`[atguigu@hadoop101 ~]$ cat /etc/shells`通过这个命令查看解析器

```shell
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
/bin/tcsh
/bin/csh
```

一般用的是`/bin/sh`和`/bin/bash`，两个有什么关系呢？

`sh`是`bash`的一种特殊的模式，也就是 `/bin/sh` 相当于 `/bin/bash --posix`。说白了`sh`就是 开启了`POSIX`(可移植操作系统接口)标准的`bash` 。`sh一般设成bash的软链`。

CentOS默认的解析器就是`/bin/bash`。

------

## 脚本入门

1.写一个Shell脚本输出HelloWorld

```shell
//声明解析器
#!/bin/bash
//逻辑代码
cd /opt/module	//去到指定目录
touch hello.txt //新建文件
echo "HelloWorld">>hello.txt //把内容输出到指定文件
```

2.脚本执行方式

- 采用`bash+脚本`或`sh+脚本` 的`相对路径`或`绝对路径`（*不用赋予脚本+x权限*）
- 直接采用脚本的`绝对路径`或`相对路径`执行脚本（*必须具有可执行权限+x*）`chmod 777` 或 `chmod u+x`
- 在脚本的路径前加上`“.”`，可以使脚本内容在当前shell里执行，而无需打开子shell，前两种都需要开子shell！

注意：开子shell与不开子shell的区别就在于，环境变量的继承关系，如在子shell中设置的当前变量，父shell是不可见的。

有以下脚本：

```shell
[root@0725pc shells]# cat test1.sh 
#! /bin/bash
A="hello"
```

分别使用sh,bash,./ 和 . 的方式来执行，结果如下：

```shell
[root@0725pc shells]# bash test1.sh 
[root@0725pc shells]# echo $A

[root@0725pc shells]# sh test1.sh 
[root@0725pc shells]# echo $A
 
[root@0725pc shells]# ./test1.sh 
[root@0725pc shells]# echo $A

[root@0725pc shells]# . test1.sh 
[root@0725pc shells]# echo $A
hello
```

------

## 变量

### 1.系统变量

不需要定义就可以直接使用的变量

`$HOME`,`$PATH`,`$PWD`,`$SHELL`等，可以通过`set`查看

### 2.自定义变量

语法：

- 定义变量`变量=值`，*=两边不能有空格*
- 撤销变量 `unset 变量`
- 声明静态变量 `readonly 变量`
- 把变量提升为全局环境变量 `export 变量名`
- 在bash中，变量默认类型都是`字符串类型`，无法直接进行数值运算
- 变量的`值`如果有空格，需要使用`双引号`或`单引号`括起来

### 3.特殊变量

- $n

  功能描述：`n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}`

- $#

  功能描述：`获取所有输入参数个数，常用于循环`

- $*

  功能描述：`这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体，它被双引号“”包含时，“$*”会将所有的参数作为一个整体`

- $@

  功能描述：`这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待`

- $?

  功能描述：`最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了`

------

## 运算符

语法：

1. $((运算式))
2. $[运算式]
3. expr  + , - , \*, /, %  expr运算符间要有空格

------

## 条件判断

语法：

`[ 条件表达式 ]` `注意表达式前后要有空格`，`条件非空即为true`

**常用判断条件**

1. 两个整数之间比较

   | `=`   | 字符串相等 |
   | ----- | ---------- |
   | `-lt` | 小于       |
   | `-le` | 小于等于   |
   | `-eq` | 等于       |
   | `-gt` | 大于       |
   | `-ge` | 大于等于   |
   | `-ne` | 不等于     |

2. 按照文件权限进行判断

   `-r`	有读的权限

   `-w`	有写的权限

   `-x`	有执行权限

3. 按照文件类型进行判断

   `-f`	文件存在并且是一个常规文件

   `-e`	文件存在

   `-d`	文件存在并且是一个目录

4. 多条件判断

   `&&` 表示前一条命令执行成功时，才执行后一条命令

   `||` 表示上一条命令执行失败后，才执行下一条命令

------

## 流程控制

### 1. if 判断

语法：

```shell
if  [ 条件判断式 ];then #if后要有空格
 程序 
fi
```

或者，

```shell
if  [ 条件判断式 ] #if后要有空格
 then 
  程序 
 elif [ 条件 ]
 then
  程序
 else
  程序
fi
```

注意：

1. [ 条件判断式 ]，中括号和条件判断式之间必须有空格
2. if后要有空格

### 2. case 语句

语法：

```shell
case $变量名 in 
 "值1") 
  # 如果变量的值等于值1，则执行程序1 
  ;;#break
 "值2") 
  # 如果变量的值等于值2，则执行程序2 
  ;;#break
 …省略其他分支… 
 *)#default
  # 如果变量的值都不是以上的值，则执行此程序 
  ;;
esac
```

### 3. for 循环

语法：

```shell
#循环递归
for (( 初始值;循环控制条件;变量变化 )) 
 do 
  程序 
 done
```

第二种语法，

```shell
#循环执行
for 变量 in 值1 值2 值3… 
 do 
  程序 
 done
```

### 4. while 循环

```shell
while  [ 条件判断式 ] #while 后面需要有空格
 do 
  程序
 done
```

------

## read读取控制台输入

语法：`read(选项)(参数)`

选项：

- -p：指定读取值时的提示符；
- -t：指定读取值时等待的时间（秒）

参数：

​    变量：指定读取值的变量名

```shell
#!/bin/bash
read -t 7 -p "Enter your name in 7 seconds " NAME
echo $NAME
```

------

## 函数

### 系统函数

1. basename

   语法：

   `basename [string / pathname] [suffix]`

   功能描述：

   `basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来`

   选项：

   `suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉`

   案例实操：

   ```shell
   #截取该/home/atguigu/banzhang.txt路径的文件名称
   #无 suffix
   [atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt 
   banzhang.txt
   #有 suffix
   [atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt
   banzhang
   ```

2. dirname

   语法：

   `dirname 文件绝对路径`

   功能描述：

   `从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）`

   案例实操：

   ```shell
   #获取banzhang.txt文件的路径
   [atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt 
   /home/atguigu
   ```

### 自定义函数

语法：

```shell
[ function ] funname[()]
{
​    Action;
​    [return int;]
}
```

注意：

1. 先声明函数，再调用
2. 函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值

------

## Shell工具

### 1.cut

语法：

`cut [选项参数]  filename`

选项：

| `-f` | 列号，提取第几列             |
| ---- | ---------------------------- |
| `-d` | 分隔符，按照指定分隔符分割列 |

说明：默认分隔符是制表符

案例实操：

（0）数据准备

```shell
[atguigu@hadoop101 datas]$ touch cut.txt
[atguigu@hadoop101 datas]$ vim cut.txt
dong shen
guan zhen
wo wo
lai lai
le le
```

（1）切割cut.txt第一列

```shell
[atguigu@hadoop101 datas]$ cut -d " " -f 1 cut.txt 
dong
guan
wo
lai
le
```

（2）切割cut.txt第二、三列

```shell
[atguigu@hadoop101 datas]$ cut -d " " -f 2,3 cut.txt 
shen
zhen
 wo
 lai
 le
```

（3）在cut.txt文件中切割出guan

```shell
[atguigu@hadoop101 datas]$ cat cut.txt | grep "guan" | cut -d " " -f 1
guan
```

（4）选取系统PATH变量值，第2个“：”开始后的所有路径：

```shell
[atguigu@hadoop101 datas]$ echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin
```

```shell
[atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2- #2- 第二列开始以后所有的内容
/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin
```

（5）切割ifconfig 后打印的IP地址

```shell
[atguigu@hadoop101 datas]$ ifconfig eth0 | grep "inet addr" | cut -d: -f 2 | cut -d" " -f1
192.168.1.102
```

### 2.sed

语法：

`sed [选项参数]  ‘command’ filename`

选项：

`-e`	直接在指令列模式上进行sed的动作编辑

命令功能：

`a` 	新增，a的后面可以接字串，在下一行出现
`d`	删除
`s`	查找并替换 

案例实操：

（0）数据准备

```shell
[atguigu@hadoop102 datas]$ touch sed.txt
[atguigu@hadoop102 datas]$ vim sed.txt
dong shen
guan zhen
wo wo
lai lai 
le le
```

（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。

```shell
[atguigu@hadoop102 datas]$ sed '2a mei nv' sed.txt 
dong shen
guan zhen
mei nv
wo wo
lai lai 
le le
```

```shell
[atguigu@hadoop102 datas]$ cat sed.txt 
dong shen
guan zhen
wo wo
lai lai
le le
```

注意：文件并没有改变

（2）删除sed.txt文件所有包含wo的行

```shell
[atguigu@hadoop102 datas]$ sed '/wo/d' sed.txt
dong shen
guan zhen
lai lai
le le
```

（3）将sed.txt文件中wo替换为ni

```shell
[atguigu@hadoop102 datas]$ sed 's/wo/ni/g' sed.txt 
dong shen
guan zhen
ni ni
lai lai
le le
```

注意：‘g’表示global，全部替换

（4）将sed.txt文件中的第二行删除并将wo替换为ni

```shell
[atguigu@hadoop102 datas]$ sed -e '2d' -e 's/wo/ni/g' sed.txt 
dong shen
ni ni 
lai lai
le le
```

### 3.wak

语法：

`awk [选项参数] ‘pattern1{action1} pattern2{action2}...’ filename`

- `pattern`：表示AWK在数据中查找的内容，就是匹配模式
- `action`：在找到匹配内容时所执行的一系列命令

选项：

`-F`	指定输入文件折分隔符
`-v`	赋值一个用户定义变量

awk的内置变量:

`FILENAME`	文件名
`NR`	已读的记录数
`NF`	浏览记录的域的个数（切割后，列的个数）

案例实操一：

（1）统计passwd文件名，每行的行号，每行的列数

```shell
[atguigu@hadoop102 datas]$ awk -F: '{print "filename:" FILENAME ", linenumber:" NR ",columns:" NF}' passwd 
filename:passwd, linenumber:1,columns:7
filename:passwd, linenumber:2,columns:7
filename:passwd, linenumber:3,columns:7
```

​     （2）切割IP

```shell
[atguigu@hadoop102 datas]$ ifconfig eth0 | grep "inet addr" | awk -F: '{print $2}' | awk -F " " '{print $1}' 
192.168.1.102
```

​     （3）查询sed.txt中空行所在的行号

```shell
[atguigu@hadoop102 datas]$ awk '/^$/{print NR}' sed.txt 
5
```



案例实操二：

（0）数据准备

`[atguigu@hadoop102 datas]$ sudo cp /etc/passwd ./`

（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。

```shell
[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $7}' passwd 
/bin/bash
```

（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。

```shell
[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $1","$7}' passwd 
root,/bin/bash
```

`注意：只有匹配了pattern的行才会执行action`

（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加"wyh, zuishuai"。

```shell
[atguigu@hadoop102 datas]$ awk -F : 'BEGIN{print "user, shell"} {print $1","$7} END{print "dahaige,/bin/zuishuai"}' passwd
user, shell
root,/bin/bash
bin,/sbin/nologin
。。。
atguigu,/bin/bash
dahaige,/bin/zuishuai
```

`注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。`

（4）将passwd文件中的用户id增加数值1并输出

```shell
[atguigu@hadoop102 datas]$ awk -v i=1 -F: '{print $3+i}' passwd
1
2
3
4
```

### 4.sort

语法：

`sort(选项)(参数)`

选项：

`-n`	依照数值的大小排序
`-r`	以相反的顺序来排序
`-t`	设置排序时所用的分隔字符
`-k`	指定需要排序的列

参数：指定待排序的文件列表

案例实操：

（0）数据准备

```shell
[atguigu@hadoop102 datas]$ touch sort.sh
[atguigu@hadoop102 datas]$ vim sort.sh 
bb:40:5.4
bd:20:4.2
xz:50:2.3
cls:10:3.5
ss:30:1.6
```

（1）按照“：”分割后的第三列倒序排序。

```shell
[atguigu@hadoop102 datas]$ sort -t : -nrk 3 sort.sh 
bb:40:5.4
bd:20:4.2
cls:10:3.5
xz:50:2.3
ss:30:1.6
```

### 5.wc

语法：

`wc [选项参数] filename`

选项：

`-l`	统计文件行数
`-w`	统计文件的单词数
`-m`	统计文件的字符数
`-c` 	统计文件的字节数

案例实操：

```shell
#统计redis_6379.conf文件的行数、单词数、字节数！
[root@0725pc myredis]# ll | grep redis_6379.conf
-rw-r--r--. 1 root root   188 10月 9 15:33 redis_6379.conf
[root@0725pc myredis]# cat -n redis_6379.conf 
   1  include /root/myredis/redis.conf
   2  pidfile "/var/run/redis_6379.pid"
   3  port 6379
   4  dbfilename "dump_6379.rdb"
   5  cluster-enabled yes
   6  cluster-config-file nodes-6379.conf
   7  cluster-node-timeout 15000
   8  
[root@0725pc myredis]# wc -w redis_6379.conf 
14 redis_6379.conf
[root@0725pc myredis]# wc -l redis_6379.conf 
8 redis_6379.conf
[root@0725pc myredis]# wc -m redis_6379.conf 
188 redis_6379.conf
```

------

## 企业真实面试题

### 11.1 京东

问题1：使用Linux命令查询file1中空行所在的行号

答案：

```
[atguigu@hadoop102 datas]$ awk '/^$/{print NR}' sed.txt 
5
```

问题2：有文件chengji.txt内容如下:

张三 40

李四 50

王五 60

使用Linux命令计算第二列的和并输出

```
[atguigu@hadoop102 datas]$ cat chengji.txt | awk -F " " '{sum+=$2} END{print sum}'
150
```

### 2.搜狐&和讯网

问题1：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？

```
#!/bin/bash
if [ -f file.txt ]; then
  echo "文件存在!"
else
  echo "文件不存在!"
fi
```

### 3 .新浪

问题1：用shell写一个脚本，对文本中无序的一列数字排序

```
[root@CentOS6-2 ~]# cat test.txt
9
8
7
6
5
4
3
2
10
1
```

```
[root@CentOS6-2 ~]# sort -n test.txt|awk '{a+=$1;print $1}END{print "SUM="a}'
1
2
3
4
5
6
7
8
9
10
SUM=55
```

### 4.金和网络

问题1：请用shell脚本写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符”shen”的文件名称

```shell
[atguigu@hadoop102 datas]$ grep -r "shen" /home | cut -d ":" -f 1
/home/atguigu/datas/sed.txt
/home/atguigu/datas/cut.txt
```