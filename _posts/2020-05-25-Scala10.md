---
layout:     post
title:      "[Scala] 隐式转换"
subtitle:   "Scala-2.11.8"
date:       2020-05-24 10:59:00
author:     "Backspace"
header-img: "img/post-bg-apple-event-2015.jpg"
tags:
    - Scala
---

## 问题导入

scala中有自动类型转换。自动的类型转换也称为隐式类型转换。比如想要把一个高精度的类型Int转换为一个低精度的类型Byte时，我们需要使用.toByte方法。违背OCP开发原则，扩展功能应该对扩展开放对修改关闭。所以最好使用一个方法，使得参数是Int类型，而返回值是Byte类型，在这个方法中调用.toByte方法,但是还是要修改代码，要想保证不改变代码的情况下还能完成任务就诞生了scala的隐式转换。

编译器会在程序出现错误时，尝试在当前作用域的范围内，找到可以让变成通过的方式，能不能通过转换让编译器编译通过，所以这种方式也称之为二次编译。

若果找到了可以转换数据类型让程序通过的方式那么编译器会在编译过程中自动完成相应逻辑的调用、这个操作开发人员看不见，所以称之为隐式转换。

编译器不是随便查找转换规则，需要加特定的标识，才能够被识别。

scala隐式转换很大的用途在于扩展功能。所谓隐式转换其实就是自动类型转换。

## 隐式转换的时机

1. 当方法中的参数的类型和目标类型不一致时。
2. 当对象调用所在类中不存在的方法和成员时。

概括来说，隐式转换的时机是在编译出现错误的时候，这种错误是可以在代码层面推断出来的

## 隐式转换的规则

隐式转换一般用于功能扩展。想扩展功能首先考虑特值trait，二就是隐式转换。而trait类似于interface和abstract，所以trait有一种共通的含义在里面，所以通用的功能可以考虑用trait。当我们要扩展的类只对某一个类有效，对别的类没有效果的时候，则考虑用隐式转换。

再进一步，如果考虑对某个对象本身进行功能扩展的时候，就不要考虑隐式变量和隐式参数了，就要用隐式函数，转换整个类型。应用于某个功能，而不是整个类型的时候就用隐式变量和隐式参数。

## 隐式函数

用于转换整个类型。把A类型转换成B类型

1. 一个函数被implicit修饰，隐式转换函数。
2. 隐式转换函数的函数名可以是任意的，隐式转换跟名称无关，只跟函数参数类型和返回类型有关
3. 隐式函数可以有多个，但是在相同环境下，只能有一个规则，不能出现规则相同的

## 隐式参数&隐式变量[隐式值]

用于功能的添加。

一个函数的参数被implicit修饰，就是隐式参数。一个变量被implicit修饰，就是隐式变量

之所以把他们放在一起是因为他们经常配合使用。

当使用隐式变量扩展参数时，调用方法**不能使用括号**。使用括号隐式参数不起作用。隐式变量也不能有相同的隐式规则

隐式参数优先于默认参数。

隐式参数一般还会结合函数柯里化使用，因为两个参数在一起写的时候，隐式参数会失效。

```
函数柯里化，把一个复杂的参数简单化。函数柯里化使用较多的场合就是隐式转换。因为隐式转换的参数要求必须有一个参数。
```

## 隐式类

一个类被implicit修饰，就是隐式类

隐式类要求：

- 构造参数有且只有一个
- 隐式类不能是顶级的，隐式类必须被定义在类或半生对象或包对象里
- 隐式类不能是caseclass

## 隐式转换要注意的地方

**规则唯一**！在相同的作用域中不能存在相同的转换规则。如果在相同的作用域中，存在相同的转换规则，那么编译器无法实现隐式转换

## 隐式转换的查找规则

1. 隐式转换在当前的作用域范围可以找到。
2. 当前作用域的父类，特质，包对象都可以查找隐式转换
3. 若果在指定的作用域中查找不到隐式转换规则，可以用import的方式进行导入